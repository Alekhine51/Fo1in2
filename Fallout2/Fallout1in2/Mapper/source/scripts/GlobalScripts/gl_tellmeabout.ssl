/*

   Adds Fallout 1 "tell me about" screen

   NOTE:
      This is just experimental code.

      As of now, the final mechanic looks something like this:
      - The player talks to a critter.
      - Once the critter dialog screen opens, gl_tellmeabout will create a button on the dialog screen (better to do this via hookscript).
      - If the critter is "valid", pressing the created button will open the input box interface (otherwise nothing happens, like in Fo1).
      - The player types in anything and hits enter / ok.
      - gl_tellmeabout will run through conditions to determine the Reply() that will be printed.
      - If the player hits ESC or close, the input box interface closes and the dialog is back to normal.

*/

/* Include Files */
#include "..\headers\command.h"
#include "..\headers\define.h"
#include "..\headers\sfall\sfall.h"
#include "..\headers\sfall\dik.h"

/* Standard Script Procedures */
procedure start;

procedure create_button;
procedure delete_button;
procedure do_on;
procedure do_off;
procedure do_off_small;
procedure do_down;
procedure do_down_small;
procedure do_up;
procedure do_up_cancel;
procedure do_up_ok;

procedure gamemodechange_handler;
procedure keypress_handler;

procedure OpenInput;
procedure CloseInput;
procedure generate_reply;

variable tellme_button;
variable fetch_input;
variable input;

#define Scr_Width          get_screen_width
#define Scr_Heigh          get_screen_height
#define SoundP             "butin4"
#define SoundR             "butout4"

variable MousonBut;
variable ButPres;
variable HiRes;

procedure start begin
   if (game_loaded) then begin
      register_hook_proc(HOOK_GAMEMODECHANGE, gamemodechange_handler);
      register_hook_proc(HOOK_KEYPRESS, keypress_handler);
   end
end

procedure gamemodechange_handler begin
   if (get_game_mode == DIALOG and tellme_button == 0) then begin
      // TMA doesn't work with party members (different interface)
      if not(obj_in_party(dialog_obj)) then
         call create_button;
   end
   else if (get_game_mode != DIALOG and tellme_button == 1) then begin
      call delete_button;
   end
end

procedure keypress_handler begin
   variable
      key_state := get_sfall_arg,
      key_dik := get_sfall_arg,
      i, key, char, abc;

   // This is for testing.

   if (fetch_input == 1 and key_state > 0) then begin
      if (key_dik == DIK_ESCAPE) then begin
         call CloseInput;
      end
      else if (key_dik == DIK_RETURN or key_dik == DIK_NUMPADENTER) then begin
         call generate_reply;
      end
      else if (key_dik == DIK_BACK and strlen(input) > 0) then begin
         input := substr(input, 0, -1);
      end
      else begin
         // TODO: Replace with something better?
         abc := {2:"1", 3:"2", 4:"3", 5:"4", 6:"5", 7:"6", 8:"7", 9:"8", 10:"9", 11:"0",
                12:"-", 13:"=", 16:"Q", 17:"W", 18:"E", 19:"R", 20:"T", 21:"Y", 22:"U", 23:"I",
                24:"O", 25:"P", 30:"A", 31:"S", 32:"D", 33:"F", 34:"G", 35:"H", 36:"J", 37:"K",
                38:"L", 39:";", 44:"Z", 45:"X", 46:"C", 47:"V", 48:"B", 49:"N", 50:"M", 51:",",
                52:".", 57: " "};

         foreach (key : char in abc) begin
            if (key == key_dik) then input := input + char;
         end
      end

      debug("input: " + input);

      // Override key with something else, because 1, 2, 3, 4, etc. can still advance through dialog
      // Allow screenshots, though
      if (key_dik != DIK_F12) then
         set_sfall_return(DIK_SPACE);
   end
end

procedure create_button begin
   tellme_button := 1;

   create_win("win_input", ((Scr_Width/2)+273), ((Scr_Heigh/2)+116), 15, 15);
   SelectWin("win_input");
   AddButton("button_input", 0, 0, 15, 15);
   AddButtonGFX("button_input", "PCX/DI_RDBT1.pcx", "PCX/DI_RDBT2.pcx", "PCX/DI_RDBT2.pcx");
   AddButtonProc("button_input", do_on, do_off, do_down, do_up);
   ShowWin;
end

procedure delete_button begin
   tellme_button := 0;

   SelectWin("win_input");
   DeleteButton("button_input");
   DeleteWin("win_input");
end

procedure do_on begin
   MousonBut := 1;
end

procedure do_off begin
   if (ButPres == 1) then
   	play_sfx("IB2LU1X1");
   MousonBut := 0;
   ButPres := 0;
end

procedure do_off_small begin
   if (ButPres == 1) then
   	play_sfx(SoundR);
   MousonBut := 0;
   ButPres := 0;
end

procedure do_down begin
   if (ButPres == 0) then begin
      ButPres := 1;
      play_sfx(SoundP);
   end
end

procedure do_down_small begin
   if (ButPres == 0) then begin
      ButPres := 1;
      play_sfx("IB1P1XX1");
   end
end

procedure do_up begin
   ButPres := 0;
   play_sfx(SoundR);
   if (fetch_input == 0) then
      call OpenInput;
end

procedure do_up_cancel begin
   ButPres := 0;
   play_sfx(SoundR);
   call CloseInput;
end

procedure do_up_ok begin
   ButPres := 0;
   play_sfx(SoundR);
   call generate_reply;
end

// Create input interface
procedure OpenInput begin
   variable valid_source;

   tma_data_array := load_array("tma_data_array");
   valid_source := tma_data_array[0];

   // Only open interface if valid TMA data has been saved
   // (computer terminals and some other critters don't have TMAs)
   if (valid_source > 0) then begin
      fetch_input := 1;
      input := "";
      //debug("TMA input enabled!");

      // Opening the interface clears the Reply window.
      // TODO: Closing the interface should restore the Reply. Probably not possible right now.
      dialog_message("");

      // Fake input / dialog option overlay
      create_win("tellme_interface", ((Scr_Width/2)-256), ((Scr_Heigh/2)+24), 512, 160);
      SelectWin("tellme_interface");
      draw_image("PCX/tellmeabout.frm", 0, 0, 0, 0);

      // CANCEL button
      AddButton("button_cancel", 271, 100, 15, 16);
      AddButtonGFX("button_cancel", "PCX/lilreddn.pcx", "PCX/lilredup.pcx", "PCX/lilredup.pcx");
      AddButtonProc("button_cancel", do_on, do_off_small, do_down_small, do_up_cancel);

      // OK button
      AddButton("button_ok", 145, 100, 15, 16);
      AddButtonGFX("button_ok", "PCX/lilreddn.pcx", "PCX/lilredup.pcx", "PCX/lilredup.pcx");
      AddButtonProc("button_ok", do_on, do_off_small, do_down_small, do_up_ok);

      ShowWin;

      // Delete the input button
      call delete_button;

      // Create windows that will block the barter and dialog history buttons
      create_win("barter_block", ((Scr_Width/2)+266), ((Scr_Heigh/2)+34), 25, 25);
      SelectWin("barter_block");
      draw_image("PCX/block_barter.frm", 0, 0, 0, 0);
      ShowWin;

      create_win("history_block", ((Scr_Width/2)-310), ((Scr_Heigh/2)+153), 60, 30);
      SelectWin("history_block");
      draw_image("PCX/block_history.frm", 0, 0, 0, 0);
      ShowWin;

      // TODO: Also have to block the "switch hand"-button on the main interface, because pressing it opens the barter screen.
      // Maybe the buttons can be disabled via some Sfall hackery instead?

   end
end

procedure CloseInput begin
   fetch_input := 0;
   //debug("TMA input disabled!");

   SelectWin("tellme_interface");
   DeleteButton("button_cancel");
   DeleteButton("button_ok");
   DeleteWin("tellme_interface");

   SelectWin("barter_block");
   DeleteWin("barter_block");

   SelectWin("history_block");
   DeleteWin("history_block");

   call create_button;
end

#define special_critter(x)    (critter_msg == x)

// talking heads
#define Aradesh               (33)
#define Butch                 (39)
#define Cabbot                (40)
#define Decker                (42)
#define Gizmo                 (44)
#define Harold                (45)
#define Jain                  (46)
#define Killian               (47)
#define Laura                 (48)
#define Loxley                (49)
#define Lou                   (50)
#define TheMaster             (51)
#define Maxson                (52)
#define Morpheus              (53)
#define Nicole                (54)
#define Overseer              (55)
#define Rhombus               (56)
#define Tandi                 (57)
#define Vree                  (58)

// party members
#define Ian                   (235)
#define Tycho                 (389)
#define Katja                 (623)

// other
//#define ...

#define critter_reply         get_reply(input, critter, reply_source, msg_offset, reply_name_start, reply_name_end, reply_unknown_start, reply_unknown_end)

procedure get_reply(variable input, variable critter, variable reply_source, variable msg_offset, variable reply_name_start, variable reply_name_end, variable reply_unknown_start, variable reply_unknown_end) begin
   variable
      i,
      input_check,
      reply_final,
      split, word, keyword;

   if (input == obj_name(critter) and reply_name_start != -1) then
      reply_final := message_str(reply_source, random(reply_name_start, reply_name_end));
   else begin
      variable found := 0;

      for (i := 0; (i < 100 and found == 0); i++) begin
         input_check := message_str(reply_source, i + msg_offset);
         if (input_check != "Error" and input_check != "") then begin
            debug("input_check: " + input_check);
            split := string_split(input_check, "|");

            foreach (word : keyword in split) begin
               if (keyword == input) then begin
                  reply_final := message_str(reply_source, (i + msg_offset) + 100);
                  found := 1;
                  break;
               end
            end
         end
      end
   end

   // No valid reply found
   if reply_final <= 0 then
      reply_final := message_str(reply_source, random(reply_unknown_start, reply_unknown_end));

   return reply_final;
end

procedure generate_reply begin
   variable
      critter := dialog_obj,
      reply_source := tma_data_array[0],
      msg_offset := tma_data_array[1],
      reply_name_start := tma_data_array[2],
      reply_name_end := tma_data_array[3],
      reply_unknown_start := tma_data_array[4],
      reply_unknown_end := tma_data_array[5],
      print_reply;

   dialog_message(critter_reply);
   input := ""; // Reset input

   /*****************************
      SPECIAL CRITTER REPLY
   *****************************/
   //reply_source := critter_msg; // use the critter script msg to find the strings
   //reply_name := -1; // not used for special critters
   //reply_unknown := random(980, 982); // is the same for most special critter
   //msg_offset := 1000; // TMAs start at line 1000 for special critters

   // Talking Heads
   /*if special_critter(TheMaster) then begin
      reply_unknown := random(1100, 1101); // The Master answers to no-one
   end

   else if special_critter(Aradesh) or
           special_critter(Butch) or
           special_critter(Cabbot) or
           special_critter(Harold) or
           special_critter(Loxley) or
           special_critter(Lou) or
           special_critter(Maxson) or
           special_critter(Morpheus) or
           special_critter(Nicole) or
           special_critter(Rhombus) or
           special_critter(Tandi) or
           special_critter(Katja)
   then begin
      // Empty :o
      // The critters use default values.
   end
   else if special_critter(Decker) then begin
      reply_unknown := random(980, 981);
   end
   else if special_critter(Gizmo) then begin
      reply_unknown := random(980, 981);
   end
   else if special_critter(Jain) then begin
      reply_unknown := 188;
   end
   else if special_critter(Killian) then begin
      reply_unknown := random(980, 983);
    end
   else if special_critter(Laura) then begin
      reply_unknown := 345;
   end
   else if special_critter(Overseer) then begin
      reply_unknown := 980;
   end
   else if special_critter(Vree) then begin
      reply_unknown := 980;
   end
   else if special_critter(Ian) then begin
      reply_unknown := 1109; // TODO : Make new strings
   end
   else if special_critter(Tycho) then begin
      reply_unknown := 1105; // TODO : Make new strings
   end*/
end
