/*

   Adds Fallout 1 "tell me about" screen

   NOTE:
      This is just experimental code.

      As of now, the final mechanic looks something like this:
      - The player talks to a critter.
      - Once the critter dialog screen opens, gl_tellmeabout will create a button on the dialog screen (better to do this via hookscript).
      - If the critter is "valid", pressing the created button will open the input box interface (otherwise nothing happens, like in Fo1).
      - The player types in anything and hits enter / ok.
      - gl_tellmeabout will run through conditions to determine the Reply() that will be printed.
      - If the player hits ESC or close, the input box interface closes and the dialog is back to normal.

*/

/* Include Files */
#include "..\headers\command.h"
#include "..\headers\define.h"
#include "..\headers\sfall\sfall.h"
#include "..\headers\sfall\dik.h"

/* Standard Script Procedures */
procedure start;

procedure create_button;
procedure delete_button;
procedure do_on;
procedure do_on;
procedure do_off;
procedure do_down;
procedure do_up;
procedure do_up_cancel;
procedure do_up_ok;

procedure gamemodechange_handler;
procedure keypress_handler;

procedure OpenInput;
procedure CloseInput;
procedure generate_reply;

variable tellme_button;
variable fetch_input;
variable input;

#define Scr_Width          get_screen_width
#define Scr_Heigh          get_screen_height
#define SoundP             get_ini_string("config\\tellme_button.ini|Button2|Butin")
#define SoundR             get_ini_string("config\\tellme_button.ini|Button2|Butou")

variable MousonBut;
variable ButPres;
variable HiRes;

procedure start begin
   if (game_loaded) then begin
      register_hook_proc(HOOK_GAMEMODECHANGE, gamemodechange_handler);
      register_hook_proc(HOOK_KEYPRESS, keypress_handler);
   end
end

procedure gamemodechange_handler begin
   if (get_game_mode == DIALOG) and tellme_button == 0 then begin
      if not(obj_in_party(dialog_obj)) then
         call create_button;
   end
   else if (get_game_mode != DIALOG) and tellme_button == 1 then
      call delete_button;
end

procedure keypress_handler begin
   variable
      i, key, char,
      key_state := get_sfall_arg,
      key_dik := get_sfall_arg,
      alphabet;

   // This is for testing.
   // A "real" input box window is prefered (for multiple reasons)

   if (fetch_input == 1 and key_state > 0) then begin
      if (key_dik == DIK_ESCAPE) then begin
         call CloseInput;
      end
      else if (key_dik == DIK_RETURN or key_dik == DIK_NUMPADENTER) then begin
         call generate_reply;
      end
      else begin
         // TODO: Replace with something better?
         alphabet := {2:"1", 3:"2", 4:"3", 5:"4", 6:"5", 7:"6", 8:"7", 9:"8", 10:"9", 11:"0",
                      12:"-", 13:"=", 16:"Q", 17:"W", 18:"E", 19:"R", 20:"T", 21:"Y", 22:"U", 23:"I",
                      24:"O", 25:"P", 30:"A", 31:"S", 32:"D", 33:"F", 34:"G", 35:"H", 36:"J", 37:"K",
                      38:"L", 39:";", 44:"Z", 45:"X", 46:"C", 47:"V", 48:"B", 49:"N", 50:"M", 51:",",
                      52:".", 57: " "};

         foreach (key : char in alphabet) begin
            if (key == key_dik) then input := input + char;
         end
         debug("input: " + input);

         // Override key with something else, because 1, 2, 3, 4, etc. can still advance through dialog
         // Allow screenshots, though
         if (key_dik != DIK_F12) then
            set_sfall_return(57);
      end
   end
end

procedure create_button begin
   tellme_button := 1;

   create_win("tellme_but", ((Scr_Width/2)+273), ((Scr_Heigh/2)+116), 14, 14);
   SelectWin("tellme_but");
   AddButton("but2", 0, 0, 14, 14);
   AddButtonGFX("but2", "PCX/DI_RDBT1.pcx", "PCX/DI_RDBT_BLANK.pcx", "PCX/DI_RDBT2.pcx");
   AddButtonProc("but2", do_on, do_off, do_down, do_up);
   ShowWin;
end

procedure delete_button begin
   fetch_input := 0;
   tellme_button := 0;

   SelectWin("tellme_but");
   DeleteButton("but2");
   DeleteWin("tellme_but");
end

procedure do_on begin
   //debug("do_on!");
   MousonBut := 1;
end

procedure do_off begin
   //debug("do_off!");
   MousonBut := 0;
end

procedure do_down begin
   //debug("do_down!");
   if (ButPres == 0) then begin
      ButPres := 1;
      play_sfx(SoundP);
   end
end

procedure do_up begin
   //debug("do_up!");

   ButPres := 0;
   play_sfx(SoundR);

   // TODO: If (critter is valid) then call OpenInput;
   if (fetch_input == 0) then
      call OpenInput;
end

procedure do_up_cancel begin
   ButPres := 0;
   play_sfx(SoundR);

   call CloseInput;
end

procedure do_up_ok begin
   ButPres := 0;
   play_sfx(SoundR);

   call generate_reply;
end

procedure OpenInput begin
   fetch_input := 1;
   input := "";
   debug("TMA input enabled!");
   // TODO: create input interface

   create_win("tellme_interface", ((Scr_Width/2)-256), ((Scr_Heigh/2)+24), 512, 160);
   SelectWin("tellme_interface");
   draw_image("PCX/tellmeabout.frm", 0, 0, 0, 0);

   // CANCEL button
   //AddButton("but3", ((Scr_Width/2)+14), ((Scr_Heigh/2)+124), 15, 16);
   AddButton("but3", 271, 100, 15, 16);
   AddButtonGFX("but3", "PCX/lilreddn.pcx", "PCX/lilredup.pcx", "PCX/lilredup.pcx");
   AddButtonProc("but3", do_on, do_off, do_down, do_up_cancel);

   // OK button
   //AddButton("but4", ((Scr_Width/2)-114), ((Scr_Heigh/2)+124), 15, 16);
   AddButton("but4", 145, 100, 15, 16);
   AddButtonGFX("but4", "PCX/lilreddn.pcx", "PCX/lilredup.pcx", "PCX/lilredup.pcx");
   AddButtonProc("but4", do_on, do_off, do_down, do_up_ok);

   ShowWin;
end

procedure CloseInput begin
   fetch_input := 0;
   debug("TMA input disabled!");

   SelectWin("tellme_interface");
   DeleteButton("but3");
   DeleteButton("but4");
   DeleteWin("tellme_interface");
end

// msg string source
#define critter_msg           (get_script(critter) + 1)
#define generic_msg           (1)

#define special_critter(x)    (critter_msg == x)

// talking heads
#define Aradesh               (33)
#define Butch                 (39)
#define Cabbot                (40)
#define Decker                (42)
#define Gizmo                 (44)
#define Harold                (45)
#define Jain                  (46)
#define Killian               (47)
#define Laura                 (48)
#define Loxley                (49)
#define Lou                   (50)
#define TheMaster             (51)
#define Maxson                (52)
#define Morpheus              (53)
#define Nicole                (54)
#define Overseer              (55)
#define Rhombus               (56)
#define Tandi                 (57)
#define Vree                  (58)

// party members
#define Ian                   (235)
#define Tycho                 (389)
#define Katja                 (623)

// other
//#define ...

#define critter_reply         get_reply(input, critter, reply_source, reply_name, reply_unknown, msg_offset)

// TODO: Create array that holds all "valid" critters where TMA is allowed? (to filter out computer terminals, etc)
// Alternatively, make a list of "invalid" critters where TMA isn't allowed... if that list is shorter.

procedure get_reply(variable input, variable critter, variable reply_source, variable reply_name, variable reply_unknown, variable msg_offset) begin
   variable
      i,
      input_check,
      reply_final;

   if (input == obj_name(critter) and reply_name != -1) then begin
      reply_final := message_str(reply_source, reply_name);
   end
   else begin
      for (i := 0; (i < 100); i++) begin
         input_check := message_str(reply_source, i + msg_offset);

         if ((input_check != "Error" and input_check != "")) then
            debug("input_check: " + input_check + " (" + (i + msg_offset) + ")");

         if (input == input_check and input != "") then begin
            debug("*** REPLY FOUND! ***");
            reply_final := message_str(reply_source, (i + msg_offset) + 100);
            i := 100;
         end
      end
   end

   // No valid reply found
   if reply_final <= 0 then
      reply_final := message_str(reply_source, reply_unknown);

   return reply_final;
end

procedure generate_reply begin
   variable
      critter := dialog_obj,
      reply_source,
      reply_name,
      reply_unknown,
      msg_offset,
      print_reply;

   /*****************************
      SPECIAL CRITTER REPLY
   *****************************/
   reply_source := critter_msg; // use the critter script msg to find the strings
   reply_name := -1; // not used for special critters
   reply_unknown := random(980, 982); // is the same for most special critter
   msg_offset := 1000; // TMAs start at line 1000 for special critters

   // Talking Heads
   if special_critter(TheMaster) then begin
      reply_unknown := random(1100, 1101); // The Master answers to no-one
   end

   // TODO: Turn into array or something, I dunno
   else if special_critter(Aradesh) or
           special_critter(Butch) or
           special_critter(Cabbot) or
           special_critter(Harold) or
           special_critter(Loxley) or
           special_critter(Lou) or
           special_critter(Maxson) or
           special_critter(Morpheus) or
           special_critter(Nicole) or
           special_critter(Rhombus) or
           special_critter(Tandi) or
           special_critter(Katja)
   then begin
      // Empty :o
      // The critters use default values.
   end
   else if special_critter(Decker) then begin
      reply_unknown := random(980, 981);
   end
   else if special_critter(Gizmo) then begin
      reply_unknown := random(980, 981);
   end
   else if special_critter(Jain) then begin
      reply_unknown := 188;
   end
   else if special_critter(Killian) then begin
      reply_unknown := random(980, 983);
    end
   else if special_critter(Laura) then begin
      reply_unknown := 345;
   end
   else if special_critter(Overseer) then begin
      reply_unknown := 980;
   end
   else if special_critter(Vree) then begin
      reply_unknown := 980;
   end
   else if special_critter(Ian) then begin
      reply_unknown := 1109; // TODO : Make new strings
   end
   else if special_critter(Tycho) then begin
      reply_unknown := 1105; // TODO : Make new strings
   end

   /*****************************
      GENERIC CRITTER REPLY
   *****************************/
   else begin
      reply_source := generic_msg;
      reply_name := random(970, 972);

      if CUR_MAP_HALLDED then
         msg_offset := 2800;
      else if CUR_MAP_HOTEL then
         msg_offset := 3400;
      else if CUR_MAP_WATRSHD then
         msg_offset := 4000;
      else if CUR_MAP_VAULT13 then
         msg_offset := 3600;
      else if CUR_MAP_JUNKENT then
         msg_offset := 7000;
      else if CUR_MAP_JUNKCSNO then
         msg_offset := 7600;
      else if CUR_MAP_JUNKKILL then
         msg_offset := 8200;
      else if CUR_MAP_BROHDENT then
         msg_offset := 8800;
      else if CUR_MAP_BROHD12 then
         msg_offset := 9400;
      else if CUR_MAP_BROHD34 then
         msg_offset := 10000;
      else if CUR_MAP_CHILDRN1 then
         msg_offset := 11200;
      else if CUR_MAP_CHILDRN2 then
         msg_offset := 11800;
      else if CUR_MAP_RAIDERS then
         msg_offset := 15400;
      else if CUR_MAP_SHADYE then
         msg_offset := 16000;
      else if CUR_MAP_SHADYW then
         msg_offset := 16600;
      else if CUR_MAP_MBENT then
         msg_offset := 19000;
      else if CUR_MAP_MBSTRG12 then
         msg_offset := 19600;
      else if CUR_MAP_MBVATS12 then
         msg_offset := 20200;
      else if CUR_MAP_MSTRLR12 then
         msg_offset := 20800;
      else if CUR_MAP_MSTRLR34 then
         msg_offset := 21400;
      else if CUR_MAP_HUBENT then
         msg_offset := 22600;
      else if CUR_MAP_HUBDWNTN then
         msg_offset := 23800;
      else if CUR_MAP_HUBHEIGT then
         msg_offset := 24400;
      else if CUR_MAP_HUBOLDTN then
         msg_offset := 25000;
      else if CUR_MAP_HUBWATER then
         msg_offset := 25600;
      else if CUR_MAP_LAADYTUM then
         msg_offset := 18000;
      else if CUR_MAP_LABLADES then
         msg_offset := 27600;
      else if CUR_MAP_LAFOLLWR then
         msg_offset := 18600;
      else if CUR_MAP_LAGUNRUN then
         msg_offset := 28800;

      // Adytum has different "knowledge levels"
      // Info Level 1 [People who know nothing]
      // Info level 2 [People who know something]
      // Info level 3 [People who know more than something but less than everything]
      // Same with Followers, Blades, and Gun Runners... need to test if this is even used by the game.
   end

   debug("Print critter reply!");
   dialog_message(critter_reply);

   input := ""; // Reset input
end
